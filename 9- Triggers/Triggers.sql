/*
    TRIGGERS
    INTRODUCCIÓN, 
*/


/*
    INTRODUCCIÓN
    Los triggers son bloques de código que se ejecutan automáticamente
    en respuesta a eventos específicos en una tabla o vista
  
    Ejemplos:
    
    DML -> INSERT, UPDATE, DELETE
    DDL -> Cambios en la estructura de la base de datos (create, drop)
    DATABASE -> Eventos del sistema (LOGON, SHUTDOWN)
*/


/*
    Tipos y eventos en los triggers
    
    TIPO:
        - DML TRIGGERS
            Eventos: INSERT, UPDATE DELETE
            Filas afectadas: 
                - Por fila(FOR EACH ROW)
                - Declaración completa (BEFORE/AFTER)
            
        - DDL TRIGGERS
            Eventos: CREATE, ALTER y DROP
            Filas afectadas:
                - Unicamente afecta a nivel de declaración
        
        - Database Triggers: 
            Eventos: LOGON, LOGOFF, SHUTDOWN, STARTUP
            Filas afectadas:
                - No afecta directamente filas, se ejecuta en
                eventos a nivel de la base de datos
            
*/


/*
    CREAR UN TRIGGER
*/


-- Creación del trigger
CREATE OR REPLACE TRIGGER TRG_INS_EMPL 
-- Después que se inserte un registro en la tabla regions se activara
AFTER INSERT ON regions
BEGIN
    -- Se guardará la siguiente información
    INSERT INTO registro_regions
    VALUES('Región incertada', USER, SYSDATE, 1);
    
END;
/


-- insertando un registro para comprobar que el trigger funcione correctamente
INSERT INTO REGIONS
VALUES(7, 'prueba');


/*
    Impedir operaciones con triggers
*/

-- Creación del trigger
CREATE OR REPLACE TRIGGER tr1_region
-- Antes que se inserte un registro en la tabla regions se activara
BEFORE INSERT ON regions
BEGIN
    -- Si el usuario es distinto a HR
    IF USER <> 'HR' THEN
        RAISE_APPLICATION_ERROR(-20000, 'Solo HR puede insertar en regions');
    END IF;
END;
/


/*
    CREAR TRIGGERS CON EVENTOS MÚLTIPLES
*/


CREATE OR REPLACE TRIGGER tr1_region
-- Antes que se inserte, actualize o elimine un registro en la tabla regions se activara
BEFORE INSERT OR UPDATE OR DELETE ON regions
BEGIN

     -- Si el usuario es distinto a HR
    IF USER <> 'HR' THEN
        RAISE_APPLICATION_ERROR(-20000, 'Solo HR puede insertar en regions');
    END IF;
END;
/


/*
    CONTROLAR EL TIPO DE EVENTO
*/


-- Creación de tabla
CREATE TABLE registro_areas
(
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,  
    REGISTRO_COLUMNA1 VARCHAR2(100 BYTE) NOT NULL,  
    NOMBRE_USUARIO VARCHAR2(40 BYTE),  
    FECHA DATE NOT NULL  
);


-- Se define el trigger
CREATE OR REPLACE TRIGGER tr1_areas_multiple
--  se activa antes de cualquier operación de INSERT, UPDATE o DELETE en la tabla REGIONS
BEFORE INSERT OR UPDATE OR DELETE ON areas
BEGIN

    -- Si se está realizando una inserción en la tabla REGIONS
    IF INSERTING THEN
        -- Se registra la operación de inserción
        INSERT INTO registro_areas(registro_columna1, nombre_usuario, fecha)
        VALUES('Insercion', USER, SYSDATE);
    END IF;
    
    -- Si se está actualizando el campo id
    IF UPDATING('id') THEN
        -- Se registra la actualización
        INSERT INTO registro_areas(registro_columna1, nombre_usuario, fecha)
        VALUES('Actualización id', USER, SYSDATE);
    END IF;
    
    -- Si se está actualizando el campo nombre
    IF UPDATING('nombre') THEN
        -- Se registra la actualización 
        INSERT INTO registro_areas(registro_columna1, nombre_usuario, fecha)
        VALUES('Actualiacion nombre', USER, SYSDATE);
    END IF;
    
    -- Si se está eliminando una area
    IF DELETING THEN
        -- Se registra la operación de eliminación 
        INSERT INTO registro_areas(registro_columna1, nombre_usuario, fecha)
        VALUES('Eliminacion', USER, SYSDATE);
    END IF;
END;
/


-- Insertando registro en la tabla areas
INSERT INTO areas
VALUES(3, 'Gerencia');

-- Actualizando registro en la tabla areas
UPDATE areas
SET nombre = 'Gerencia2'
WHERE id = 4;

-- Eliminando registro en la tabla areas
DELETE FROM areas
WHERE id = 4;

-- Insertando registro en la tabla areas
INSERT INTO areas
VALUES(5, 'Recursos humanos');


/*
    TRIGGERS DE TIPO ROW
    
    se ejecutan una vez por cada fila afectada por una operación DML 
    (INSERT, UPDATE, DELETE). Estos triggers permiten controlar y realizar acciones 
    sobre cada fila modificada, accediendo a los valores antiguos y nuevos de los campos 
    mediante las variables :OLD y :NEW.
    
    En un INSERT: se utiliza :NEW para acceder a los valores recién insertados.
    En un DELETE: se utiliza :OLD para acceder a los valores que están a punto de ser eliminados.
    En un UPDATE: se utilizan :OLD para obtener los valores anteriores, y :NEW para obtener los valores actualizados.
*/


-- Se define el trigger
CREATE OR REPLACE TRIGGER tr1_areas_multiple_each_row
--  se activa antes de cualquier operación de INSERT, UPDATE o DELETE en la tabla REGIONS
BEFORE INSERT OR UPDATE OR DELETE 
ON areas
FOR EACH ROW
WHEN (NEW.id >100) -- Solo se activa cuando el id sea mayor a 100
BEGIN

    -- Si se está realizando una inserción en la tabla REGIONS
    IF INSERTING THEN
        -- Se registra la operación de inserción
        INSERT INTO registro_areas(registro_columna1, nombre_usuario, fecha)
        VALUES('Nuevo valor: ' || :NEW.nombre, USER, SYSDATE);
    END IF;
    
    -- Si se está actualizando el campo id
    IF UPDATING('id') THEN
        -- Se registra la actualización
        INSERT INTO registro_areas(registro_columna1, nombre_usuario, fecha)
        VALUES('Actualización id', USER, SYSDATE);
    END IF;
    
    -- Si se está actualizando el campo nombre
    IF UPDATING('nombre') THEN
        -- Se registra la actualización 
        INSERT INTO registro_areas(registro_columna1, nombre_usuario, fecha)
        VALUES('Actualiacion nombre', USER, SYSDATE);
    END IF;
    
    -- Si se está eliminando una area
    IF DELETING THEN
        -- Se registra la operación de eliminación 
        INSERT INTO registro_areas(registro_columna1, nombre_usuario, fecha)
        VALUES('Eliminacion', USER, SYSDATE);
    END IF;
END;
/


/*
    COMPROBAR EL ESTADO DE LOS TRIGGERS
    
*/


DESC USER_TRIGGERS;
SELECT 
    trigger_name, 
    trigger_type, 
    trigger_body
FROM
    USER_TRIGGERS;
    
    
/*
    DESACTIVAR TRIGGER
*/

ALTER TRIGGER tr1_areas_multiple_each_row DISABLE;

/*
    ACTIVAR TRIGGER
*/

ALTER TRIGGER tr1_areas_multiple_each_row ENABLE;


/*
    COMPILAR
*/


ALTER TRIGGER tr1_areas_multiple_each_row COMPILE;


/*
    TRIGGGER COMPOUND -> TRIGGERS COMPUESTOS
    Un Compound Trigger en PL/SQL es un tipo especial de trigger que combina 
    múltiples secciones para manejar eventos BEFORE y AFTER en un mismo bloque, 
    lo que permite reducir el uso de variables globales y optimizar el rendimiento.
    
    - Varios momentos en un solo trigger: Puedes manejar eventos como 
    BEFORE y AFTER para INSERT, UPDATE o DELETE en un solo trigger.
    
    - Optimización para filas: Es útil cuando se trabaja con filas múltiples (operaciones bulk), 
    ya que puede manejar eventos por bloque de filas, en lugar de activarse para cada fila individualmente.
    
    Secciones: Un compound trigger tiene hasta cuatro secciones opcionales:
    
        - BEFORE STATEMENT: Se ejecuta una vez antes de cualquier fila.
        
        - BEFORE EACH ROW: Se ejecuta antes de cada fila afectada.
        
        - AFTER EACH ROW: Se ejecuta después de cada fila afectada.
        
        - AFTER STATEMENT: Se ejecuta una vez después de que todas las filas hayan sido procesadas
*/



CREATE OR REPLACE TRIGGER TRG_COMPOUND
FOR INSERT OR UPDATE ON areas
COMPOUND TRIGGER

  -- Sección BEFORE STATEMENT para inicializar variables,validaciones
  -- BEFORE STATEMENT: Se ejecuta una vez antes de cualquier fila.
  BEFORE STATEMENT IS
  BEGIN
    dbms_output.put_line('BEFORE STATEMENT');
  END BEFORE STATEMENT;

  -- Sección BEFORE EACH ROW
  -- BEFORE EACH ROW: Se ejecuta antes de cada fila afectada.
  BEFORE EACH ROW IS
  BEGIN
    dbms_output.put_line('BEFORE EACH ROW');
  END BEFORE EACH ROW;

  -- Sección AFTER EACH ROW
  -- AFTER EACH ROW: Se ejecuta después de cada fila afectada.
  AFTER EACH ROW IS
  BEGIN
    dbms_output.put_line('AFTER EACH ROW');
  END AFTER EACH ROW;

  -- Sección AFTER STATEMENT
  -- AFTER STATEMENT: Se ejecuta una vez después de que todas las filas hayan sido procesadas.
  AFTER STATEMENT IS
  BEGIN
    dbms_output.put_line('AFTER STATEMENT');
  END AFTER STATEMENT;

END trg_compound;
/


/*
    Ejemplo adaptado
*/


CREATE OR REPLACE TRIGGER tr1_areas_compound
FOR INSERT OR UPDATE OR DELETE ON areas
COMPOUND TRIGGER

  -- Variables globales
  usuario VARCHAR2(50);
  fecha DATE;

  -- Sección BEFORE STATEMENT
  BEFORE STATEMENT IS
  BEGIN
    -- Inicialización
    usuario := USER;
    fecha := SYSDATE;
  END BEFORE STATEMENT;

  -- Sección BEFORE EACH ROW
  BEFORE EACH ROW IS
  BEGIN
    -- Verificar si el id es mayor a 100
    IF :NEW.id > 100 THEN
      -- Si se está realizando una inserción
      IF INSERTING THEN
        INSERT INTO registro_areas(registro_columna1, nombre_usuario, fecha)
        VALUES('Nuevo valor: ' || :NEW.nombre, usuario, fecha);
      END IF;

      -- Si se está actualizando el campo id
      IF UPDATING('id') THEN
        INSERT INTO registro_areas(registro_columna1, nombre_usuario, fecha)
        VALUES('Actualización id', usuario, fecha);
      END IF;

      -- Si se está actualizando el campo nombre
      IF UPDATING('nombre') THEN
        INSERT INTO registro_areas(registro_columna1, nombre_usuario, fecha)
        VALUES('Actualización nombre', usuario, fecha);
      END IF;

      -- Si se está eliminando una área
      IF DELETING THEN
        INSERT INTO registro_areas(registro_columna1, nombre_usuario, fecha)
        VALUES('Eliminación', usuario, fecha);
      END IF;
      
    END IF;
  END BEFORE EACH ROW;

END tr1_areas_compound;
/


/*
    PRACTICAS PRIMERA PARTE, INSERT, DELEET Y UPDATE
*/


/*
     EJERCICIO 1:
     CREAR TRIGGER DE AUDITORÍA AL INSERTAR EN LA TABLA areas
     Crea un trigger que se active después de una inserción en la tabla 
     areas. Al activarse, debe insertar un registro en una tabla de auditoría 
     llamada auditoria_area, almacenando el nombre de la area insertado, el usuario que realizó 
     la acción, y la fecha de la operación.
*/


-- Creación del trigger
CREATE OR REPLACE TRIGGER TR_auditoria_area
AFTER INSERT ON areas
FOR EACH ROW
BEGIN
    -- Insertar registro despues de cada inserción en la tabla
    INSERT INTO auditoria_area(area_incertada, usuario, fecha_operacion)
    VALUES(:NEW.nombre, USER, SYSDATE);
END;
/


-- Insertando registro
INSERT INTO areas
VALUES(6, 'Gerencia');


/*
    EJERCICIO 2:
    Trigger al borrar registros en departments: 
    Crea un trigger que se active antes de eliminar un registro 
    en la tabla departments. El trigger debe insertar un registro en una tabla 
    llamada registro_departments_eliminados, indicando el nombre del departamento eliminado y
    la fecha.
*/


-- Creación de tabla
CREATE TABLE registro_departments_eliminados (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    departamento VARCHAR2(100) NOT NULL,
    fecha_operacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Creación del trigger
CREATE OR REPLACE TRIGGER TR_ELIMINAR_DEPARTAMENTOS
AFTER INSERT ON departments
FOR EACH ROW
BEGIN
    -- Insertar después de que se elimina un registro en lla tabla departments
    INSERT INTO registro_departments_eliminados(departamento, fecha_operacion)
    VALUES(:NEW.department_name, SYSDATE);
END;
/


/*
    EJERCICIO 3:
    rigger al actualizar el salario en employees: Crea un trigger que se ejecute 
    después de una actualización del salario en la tabla employees. El trigger debe 
    guardar en una tabla log_cambios_salario el employee_id, el salario antes del cambio, 
    el salario después del cambio, y la fecha del cambio.
*/


-- Creación de la tabla
CREATE TABLE log_cambios_salario (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_empleado NUMBER NOT NULL,
    salario_antes NUMBER,
    salario_despues NUMBER NOT NULL
);


-- Creación del trigger
CREATE OR REPLACE TRIGGER tr_salarios_empleados
AFTER UPDATE ON employees
FOR EACH ROW
BEGIN
    -- Insertar
    INSERT INTO log_cambios_salario (id_empleado, salario_antes, salario_despues)
    VALUES(:NEW.employee_id, :OLD.salary, :NEW.salary);
END;
/


-- Actualizando salario
UPDATE EMPLOYEES
SET
    salary = 5000
WHERE employee_id = 100;    


/*
    PRACTICA SEGUNDA PARTE, IMPEDIR OPERACIONES CON TRIGGERS
*/


/*
    EJERCICIO 1:
    Evitar inserciones en employees fuera del horario laboral: 
    Crea un trigger que impida realizar inserciones en la tabla 
    employees fuera del horario laboral (por ejemplo, de 8:00 AM a 6:00 PM), 
    usando la función SYSDATE para obtener la hora actual.
*/


CREATE OR REPLACE TRIGGER TR_EVITAR_INSERCIONES_EMPLOYEES
BEFORE INSERT ON employees
BEGIN
    IF TO_CHAR(SYSDATE, 'HH24:MI') < '08:00' AND TO_CHAR(SYSDATE, 'HH24:MM') > '18:00' THEN
        RAISE_ERROR_APPLICATION('-20001', 'No se puede insertar fuera del horario laboral');
    END IF;
END;
/


/*
    EJERCICIO 2:
    Evitar actualizaciones de salario por parte de usuarios 
    no autorizados: Crea un trigger que impida actualizar el 
    salario de los empleados en la tabla employees si el 
    usuario que intenta hacer la operación no pertenece al 
    departamento de Recursos Humanos (HR).
*/


CREATE OR REPLACE TRIGGER TR_REGULAR_USUARIO_NO_ACTUALIZADO
BEFORE UPDATE ON employees
BEGIN
    
    IF USER <> 'HR' THEN
        IF UPDATING('salary') THEN
                RAISE_APPLICATION_ERROR('-20002', 'No se puede actualizar el salario');
        END IF;    
    END IF;
   
END;
/


/*
    PRACTICA TERCERA PARTE TRIGGERS CON EVENTOS MÚLTIPLES
*/


/*
    EJERCICIO 1:
    Trigger múltiple para employees: Crea un trigger que se active antes 
    de cualquier operación(insert, update o delete) en la tabla employees. 
    Si la operación es realizada por un usuario distinto de HR, 
    debe levantar un error con RAISE_APPLICATION_ERROR.
*/


CREATE OR REPLACE TRIGGER TR_MULTIPLE_EMPLOYEES
BEFORE INSERT OR DELETE OR UPDATE 
ON employees
BEGIN
    IF USER <> 'HR' THEN
        RAISE_APPLICATION_ERROR(-20003, 'No puede realizar ninguna acción de INSERT, UPDATE Y DELETE');
    END IF;
END;
/


/*
    EJERCICIO 2:
    Trigger para limitar operaciones en departments: 
    Crea un trigger que se active antes de cualquier operación 
    (insert, update, delete) en la tabla departments. 
    Si el departamento es el de IT, debe impedir cualquier 
    cambio, mostrando un mensaje de error que indique 
    "El departamento IT no puede ser modificado".
*/


CREATE OR REPLACE TRIGGER TR_LIMITAR_OPERACIONES_DEPARTMENTS
BEFORE INSERT OR UPDATE OR DELETE ON departments
FOR EACH ROW
BEGIN
    IF :NEW.department_name = 'IT' THEN
        RAISE_APPLICATION_ERROR(-20004, 'El departamento IT no puede ser modificado');
    END IF;
END;
/


SELECT * FROM DEPARTMENTS;


/*
    PRACTICA CUARTA PARTE TRIGGERS COMPOUND
*/


/*
    EJERCICIO 1:
    Crea un trigger compound que controle las operaciones de inserción, actualización 
    y eliminación sobre la tabla areas.
    
    En la sección BEFORE STATEMENT, inicializa una variable que cuente 
    el número de operaciones.
    
    En la sección BEFORE EACH ROW, incrementa el contador si se inserta, 
    actualiza, o elimina un registro.
    
    En la sección AFTER STATEMENT, muestra un mensaje con la cantidad de 
    registros que se afectaron en la operación.
*/


-- Creación de tabla
CREATE TABLE control_operaciones
(
    ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,  
    operacion VARCHAR2(100 BYTE) NOT NULL,  
    cantidad NUMBER,  
    fecha DATE NOT NULL  
);


-- Creación del trigger
CREATE OR REPLACE TRIGGER TR_CONTROL_OPERACIONES_COMPOUND
FOR INSERT OR UPDATE OR DELETE ON AREAS
COMPOUND TRIGGER

    -- Declaración de variable global
    contador NUMBER;
    
    -- Inicialización
    BEFORE STATEMENT 
    IS
    BEGIN
        contador := 0;
    END BEFORE STATEMENT;
    
    -- Se aumenta
    BEFORE EACH ROW
    IS  
    BEGIN
        
        -- Insertar registro
        IF INSERTING THEN
            contador := contador + 1;
            
            INSERT INTO control_operaciones (operacion, cantidad, fecha)
            VALUES('Insert', contador, sysdate);
        END IF;
        
        -- Actualizar registro
        IF UPDATING THEN
            contador := contador + 1;
            
            INSERT INTO control_operaciones (operacion, cantidad, fecha)
            VALUES('Update', contador, sysdate);
        END IF;
        
        -- Eliminar registro
        IF DELETING THEN
            contador := contador + 1;
            
            INSERT INTO control_operaciones (operacion, cantidad, fecha)
            VALUES('Delete', contador, sysdate);
        END IF;
    END BEFORE EACH ROW;
    
        
    AFTER STATEMENT
    IS
    BEGIN
        dbms_output.put_line('Cantidad: ' || contador);
    END AFTER STATEMENT;

END TR_CONTROL_OPERACIONES_COMPOUND;
/


SELECT * FROM AREAS;

INSERT INTO AREAS
VALUES(7, 'Ejemplo');

UPDATE AREAS
SET NOMBRE = 'Ejemplo modificado'
WHERE id = 7;


SELECT * FROM control_operaciones;